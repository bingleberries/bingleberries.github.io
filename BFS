<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>bingletonâ€™s fight simulator - WASD + per-character specials</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
  <style>
    body { margin:0; background:#0b0b0f; color:#eee; font-family:Inter,Arial,Helvetica,sans-serif; }
    #game { display:block; margin:0 auto; }
    .note { width:100%; max-width:1100px; margin:8px auto; text-align:center; color:#bbb; }
  </style>
</head>
<body>
  <div class="note">bingletonâ€™s fight simulator â€” prototype. Use W A S D to move, J light, K heavy, each character has its own special (Q / E / R). ðŸ‘€</div>
  <div id="game"></div>

<script>
/* Updated prototype:
   - Movement: WASD for all characters (W jump, A left, D right, S down)
   - Each character has its own special key:
       Kaze -> Q
       Rin  -> E
       Tsu  -> R
   - HUD shows special key for active character
*/

/* =========================
   Config & Constants
   ========================= */
const GAME_WIDTH = 1024;
const GAME_HEIGHT = 640;

const PLAYER_DEFAULTS = {
  size: { w: 48, h: 96 },
  speed: 260,
  jumpSpeed: 520,
  gravity: 1600,
  maxHP: 100,
  attackCooldown: 220,
  heavyCooldown: 700,
  specialCost: 40,
  specialMax: 100
};

const CHUNK_W = 1600;
const CHUNK_H = GAME_HEIGHT;
const WORLD_CHUNKS = 5;

/* Simple pool */
class Pool {
  constructor(createFn, initial = 10) {
    this.createFn = createFn;
    this.pool = [];
    for (let i=0;i<initial;i++) this.pool.push(createFn());
  }
  get() { return this.pool.length ? this.pool.pop() : this.createFn(); }
  release(obj) { if (obj.reset) obj.reset(); this.pool.push(obj); }
}

/* Scenes */
class Boot extends Phaser.Scene {
  constructor() { super({ key: 'Boot' }); }
  preload() {}
  create() { this.scene.start('Preload'); }
}

class Preload extends Phaser.Scene {
  constructor(){ super({ key: 'Preload' }); }
  create() {
    this.createCharacterTextures();
    this.createEnemyTextures();
    this.createItemTextures();
    this.scene.start('Main');
  }

  createCharacterTextures(){
    const chars = [
      { key: 'kaze', color: 0x66ccff, outline: 0x0b3250 },
      { key: 'rin', color: 0xff8a8a, outline: 0x5a0b0b },
      { key: 'tsu', color: 0xb57cff, outline: 0x2f0b3c }
    ];
    chars.forEach((ch, idx)=>{
      const w = PLAYER_DEFAULTS.size.w, h = PLAYER_DEFAULTS.size.h;
      for (const anim of ['idle','walk','jump','punch','heavy','special']) {
        const tex = `${ch.key}_${anim}`;
        const g = this.make.graphics({x:0,y:0,add:false});
        g.fillStyle(ch.color, 1);
        g.fillRoundedRect(0,0,w,h,8);
        g.lineStyle(4, ch.outline);
        g.strokeRoundedRect(0,0,w,h,8);
        g.fillStyle(0xffffff, 1);
        const fx = (anim==='walk')? 6 : (anim==='punch') ? 14 : (anim==='heavy') ? 24 : 10;
        g.fillCircle(w - fx, 20 + idx*2, 10);
        if (anim === 'special') {
          g.fillStyle(0xffff66, 0.12);
          g.fillCircle(w/2, h/2, Math.min(w,h)*0.9);
        }
        g.generateTexture(tex, w, h);
        g.destroy();
      }
    });
  }

  createEnemyTextures() {
    const types = [
      {key:'thug', color:0x8a8a8a},
      {key:'knife', color:0xffd166},
      {key:'heavy', color:0x9b5f4f},
      {key:'drone', color:0xbce6ff}
    ];
    types.forEach(t=>{
      const w=64, h=64;
      const g = this.make.graphics({add:false});
      g.fillStyle(t.color, 1);
      g.fillRoundedRect(0,0,w,h,10);
      g.lineStyle(3, 0x000000, 0.25);
      g.strokeRoundedRect(0,0,w,h,10);
      g.generateTexture(t.key, w, h);
      g.destroy();
    });
  }

  createItemTextures() {
    const items = [
      {key:'health', color:0xff6666},
      {key:'adrenaline', color:0x66ff66},
      {key:'coin', color:0xffdd55}
    ];
    items.forEach(it=>{
      const size=36;
      const g = this.make.graphics({add:false});
      g.fillStyle(it.color,1);
      g.fillCircle(size/2, size/2, size/2);
      g.lineStyle(2, 0x111111);
      g.strokeCircle(size/2, size/2, size/2);
      g.generateTexture(it.key, size, size);
      g.destroy();
    });
  }
}

class Main extends Phaser.Scene {
  constructor(){ super({ key: 'Main' }); }
  init() {
    this.player = null;
    this.spawnZones = [];
    this.currentChunkIndex = 0;
  }

  create(){
    const worldW = CHUNK_W * WORLD_CHUNKS;
    const worldH = CHUNK_H;
    this.physics.world.setBounds(0, 0, worldW, worldH);
    this.cameras.main.setBounds(0, 0, worldW, worldH);
    this.cameras.main.setBackgroundColor('#10111a');

    this.platforms = this.physics.add.staticGroup();
    for (let i=0;i<WORLD_CHUNKS;i++){
      const ground = this.add.rectangle(i*CHUNK_W + CHUNK_W/2, GAME_HEIGHT - 24, CHUNK_W, 48, 0x222233);
      this.physics.add.existing(ground, true);
      this.platforms.add(ground);
      for (let c=0;c<6;c++){
        const x = i*CHUNK_W + 120 + Math.random()*(CHUNK_W-240);
        const y = GAME_HEIGHT - 24 - (Math.random()*120);
        const rect = this.add.rectangle(x,y,80,40, 0x3a3a4a);
        this.physics.add.existing(rect, true);
        this.platforms.add(rect);
      }
      this.spawnZones.push({
        xStart: i*CHUNK_W + 80,
        xEnd: i*CHUNK_W + CHUNK_W - 80,
        intensity: 1 + Math.floor(Math.random()*3)
      });
    }

    this.enemies = this.physics.add.group();
    this.enemyPool = new Pool(()=>this.createEnemy(), 12);
    this.items = this.physics.add.group();
    this.itemPool = new Pool(()=>this.createItem(), 6);
    this.hitboxPool = new Pool(()=>this.createHitbox(), 12);

    // Characters now include per-character special key (as lowercase key name matching addKeys)
    this.playerSelectIndex = 0;
    this.characters = [
      { id:'kaze', name:'Kaze', speed:320, power:9, defense:3, specialGain:1.0, specialKey:'q' },
      { id:'rin',  name:'Rin',  speed:260, power:12, defense:5, specialGain:1.0, specialKey:'e' },
      { id:'tsu',  name:'Tsu',  speed:210, power:18, defense:9, specialGain:0.9, specialKey:'r' }
    ];

    const spawnX = worldW/2;
    this.player = new PlayerCharacter(this, spawnX, GAME_HEIGHT - 140, this.characters[this.playerSelectIndex]);
    this.add.existing(this.player);
    this.physics.add.existing(this.player);
    this.player.body.setSize(PLAYER_DEFAULTS.size.w * 0.8, PLAYER_DEFAULTS.size.h, true);

    this.physics.add.collider(this.player, this.platforms);
    this.physics.add.collider(this.enemies, this.platforms);
    this.physics.add.collider(this.enemies, this.enemies);

    this.cameras.main.startFollow(this.player);
    this.cameras.main.setZoom(1);

    // INPUT: WASD for movement + J/K for attacks + Q/E/R registered for specials
    this.keys = this.input.keyboard.addKeys({
      left: 'A', right: 'D', up:'W', down:'S',
      light: 'J', heavy: 'K', swap: 'TAB',
      q: 'Q', e: 'E', r: 'R'
    });

    this.input.gamepad.once('connected', pad=>{ this.pad = pad; });

    // HUD
    this.createHUD();

    this.time.addEvent({ delay: 800, callback: ()=> this.spawnWave(4), callbackScope: this, repeat: 0 });
    this.time.addEvent({ delay: 2000, loop: true, callback: ()=> { this.spawnFromActiveChunk(); }});
    this.debugMode = false;
    this.input.keyboard.on('keydown_T', ()=> this.debugMode = !this.debugMode);
  }

  update(time, delta){
    if (this.player) this.player.update(time, delta);

    this.enemies.getChildren().forEach(e=>{
      if (e.active && e.updateAI) e.updateAI(time, delta);
      const cam = this.cameras.main;
      if (Math.abs(e.x - cam.midPoint.x) > cam.width*1.6) {
        if (e._canPool) this.removeEnemy(e);
      }
    });

    this.items.getChildren().forEach(it=>{
      if (!it.active) return;
      if (it.lifetime && this.time.now - it.spawnTime > it.lifetime) this.recycleItem(it);
    });

    this.updateHUD();

    const newChunk = Math.floor(this.player.x / CHUNK_W);
    if (newChunk !== this.currentChunkIndex) this.currentChunkIndex = Phaser.Math.Clamp(newChunk, 0, WORLD_CHUNKS-1);
  }

  createHUD(){
    this.hud = this.add.container(16,16).setScrollFactor(0);
    this.hpBg = this.add.rectangle(0,0,300,28,0x111111).setOrigin(0);
    this.hpBar = this.add.rectangle(4,4,292,20,0xff6666).setOrigin(0);
    this.hud.add([this.hpBg, this.hpBar]);
    this.specialBg = this.add.rectangle(0,38,300,18,0x111111).setOrigin(0);
    this.specialBar = this.add.rectangle(4,42,0,10,0x66ff66).setOrigin(0);
    this.hud.add([this.specialBg, this.specialBar]);
    this.comboText = this.add.text(320, 0, 'Combo: 0', { font: '20px monospace', fill:'#fff' }).setScrollFactor(0);
    this.hud.add(this.comboText);
    this.moneyText = this.add.text(320, 28, 'Â¥ 0', { font: '18px monospace', fill:'#fff' }).setScrollFactor(0);
    this.hud.add(this.moneyText);
    this.charText = this.add.text(16, -28, 'CHAR: ' + this.player.profile.name + ' (Special: ' + this.player.profile.specialKey.toUpperCase() + ')', { font: '16px monospace', fill:'#ddd' }).setScrollFactor(0);
    this.hud.add(this.charText);
  }

  updateHUD(){
    const p = this.player;
    const hpRatio = Phaser.Math.Clamp(p.hp / p.maxHP, 0, 1);
    this.hpBar.width = 292 * hpRatio;
    const spRatio = Phaser.Math.Clamp(p.special / p.specialMax, 0, 1);
    this.specialBar.width = 292 * spRatio;
    this.comboText.setText('Combo: ' + p.comboCounter);
    this.moneyText.setText('Â¥ ' + p.money);
    this.charText.setText('CHAR: ' + this.player.profile.name + ' (Special: ' + this.player.profile.specialKey.toUpperCase() + ')');
  }

  createEnemy(){
    const spr = this.add.sprite(-1000,-1000,'thug').setActive(false).setVisible(false);
    this.physics.add.existing(spr);
    spr.body.setSize(44, 54);
    spr.body.setCollideWorldBounds(true);
    spr.hp = 20; spr.maxHP = 20; spr.speed = 90; spr._canPool = false;
    spr.takeDamage = (damage, source) => {
      if (!spr.active) return;
      spr.hp -= damage;
      spr.tint = 0xffaaaa;
      this.time.delayedCall(80, ()=> { if (spr) spr.clearTint(); });
      if (source && source.x) {
        const dir = spr.x < source.x ? -1 : 1;
        spr.body.velocity.x = dir * 160;
      }
      if (spr.hp <= 0) this.killEnemy(spr);
    };
    spr.updateAI = (time, delta) => {
      const cam = this.cameras.main;
      if (Math.abs(spr.x - cam.midPoint.x) > cam.width*1.2) return;
      const px = this.player.x;
      const dx = px - spr.x;
      const absdx = Math.abs(dx);
      if (absdx > 48) {
        spr.body.velocity.x = (dx > 0) ? spr.speed : -spr.speed;
        spr.flipX = spr.body.velocity.x > 0;
      } else spr.body.velocity.x = 0;
      if (absdx < 60 && Math.abs(spr.y - this.player.y) < 40) {
        if (!spr._atkCooldown || time > spr._atkCooldown) {
          spr._atkCooldown = time + 1000;
          if (!this.player.invulnerable) {
            this.player.takeDamage(8, spr);
            this.player.comboResetAfter(800);
          }
        }
      }
    };
    spr.reset = function() {
      this.setActive(false); this.setVisible(false);
      if (this.body) { this.body.stop(); this.body.enable = false; }
      this._canPool = false;
    };
    return spr;
  }

  spawnWave(count=3){ for (let i=0;i<count;i++) this.spawnEnemyAtRandom(); }
  spawnEnemyAtRandom(){
    const zone = this.spawnZones[Phaser.Math.Between(0, this.spawnZones.length-1)];
    const x = Phaser.Math.Between(zone.xStart, zone.xEnd);
    const y = GAME_HEIGHT - 120;
    this.spawnEnemyAt(x, y);
  }

  spawnEnemyAt(x, y, type='thug') {
    const e = this.enemyPool.get();
    e.setTexture(type);
    e._canPool = false;
    e.hp = (type==='heavy') ? 45 : (type==='knife'? 18 : 20);
    e.maxHP = e.hp;
    e.speed = (type==='heavy') ? 60 : (type==='knife'? 140 : 90);
    e._spawnTime = this.time.now;
    e.setActive(true); e.setVisible(true);
    if (e.body) { e.body.enable = true; e.body.reset(x, y); } else { this.physics.add.existing(e); }
    e.x = x; e.y = y;
    e.setScale(1); e.flipX = Math.random() > 0.5;
    this.enemies.add(e);
    this.tweens.add({ targets: e, alpha: { from:0, to:1 }, scale: { from:0.8, to:1 }, duration: 220, ease: 'Power2' });
    return e;
  }

  killEnemy(e) {
    if (!e || !e.active) return;
    const coinChance = 0.6;
    if (Math.random() < coinChance) {
      const it = this.itemPool.get();
      it.setActive(true).setVisible(true);
      it.spawn(this, e.x + Phaser.Math.Between(-20,20), e.y, 'coin');
      this.items.add(it);
    } else if (Math.random() < 0.25) {
      const it = this.itemPool.get();
      it.setActive(true).setVisible(true);
      it.spawn(this, e.x + Phaser.Math.Between(-20,20), e.y, 'health');
      this.items.add(it);
    }
    const fx = this.add.circle(e.x, e.y - 20, 8, 0xffcc88).setDepth(40);
    this.tweens.add({ targets: fx, alpha: {from:1,to:0}, y: fx.y-30, duration:300, onComplete: ()=> fx.destroy() });
    this.removeEnemy(e);
    if (Math.random() < 0.12) this.time.delayedCall(700, ()=> this.spawnEnemyAt(e.x + 100, e.y, 'knife'));
  }

  removeEnemy(e) {
    if (!e) return;
    try {
      e._canPool = true;
      e.setActive(false); e.setVisible(false);
      if (e.body) { e.body.stop(); e.body.enable = false; }
      this.enemies.remove(e);
      this.enemyPool.release(e);
    } catch (err) {}
  }

  createHitbox() {
    const r = this.add.rectangle(-1000,-1000,40,20,0xff0000,0.0).setActive(false).setVisible(false);
    this.physics.add.existing(r);
    r.body.setAllowGravity(false);
    r.reset = function(){ this.setActive(false); this.setVisible(false); if (this.body) { this.body.enable=false; } };
    return r;
  }

  createItem() {
    const spr = this.add.sprite(-9999,-9999,'coin').setActive(false).setVisible(false);
    this.physics.add.existing(spr);
    spr.body.setAllowGravity(true);
    spr.spawn = (scene,x,y,key) => {
      spr.setTexture(key);
      spr.x = x; spr.y = y - 10;
      spr.spawnTime = scene.time.now;
      spr.lifetime = 12000;
      spr.setActive(true); spr.setVisible(true);
      spr.body.enable = true;
      spr.body.setVelocityY(-160);
    };
    spr.reset = function(){ this.setActive(false); this.setVisible(false); if (this.body) { this.body.stop(); this.body.enable=false; } };
    return spr;
  }

  recycleItem(it) {
    it.setActive(false); it.setVisible(false);
    if (it.body) { it.body.stop(); it.body.enable = false; }
    this.itemPool.release(it);
    this.items.remove(it);
  }

  spawnFromActiveChunk(){
    const zone = this.spawnZones[this.currentChunkIndex];
    if (!zone) return;
    const spawnChance = 0.45 * zone.intensity;
    if (Math.random() < spawnChance) {
      const x = Phaser.Math.Between(zone.xStart, zone.xEnd);
      const types = ['thug','knife','heavy'];
      const type = Phaser.Utils.Array.GetRandom(types);
      this.spawnEnemyAt(x, GAME_HEIGHT - 120, type);
    }
  }
}

/* PlayerCharacter */
class PlayerCharacter extends Phaser.GameObjects.Container {
  constructor(scene, x, y, profile) {
    super(scene, x, y);
    this.scene = scene;
    this.profile = profile;
    this.setSize(PLAYER_DEFAULTS.size.w, PLAYER_DEFAULTS.size.h);
    this.sprite = scene.add.sprite(0, 0, `${profile.id}_idle`).setOrigin(0.5,1);
    this.add(this.sprite);

    scene.physics.world.enable(this);
    this.body.setCollideWorldBounds(true);
    this.body.setSize(PLAYER_DEFAULTS.size.w * 0.8, PLAYER_DEFAULTS.size.h, true);

    this.maxHP = PLAYER_DEFAULTS.maxHP + (profile.defense*2);
    this.hp = this.maxHP;
    this.speed = profile.speed || PLAYER_DEFAULTS.speed;
    this.jumpSpeed = PLAYER_DEFAULTS.jumpSpeed;
    this.gravity = PLAYER_DEFAULTS.gravity;
    this.attackCooldown = PLAYER_DEFAULTS.attackCooldown;
    this.heavyCooldown = PLAYER_DEFAULTS.heavyCooldown;
    this.attackTimer = 0;
    this.heavyTimer = 0;
    this.facing = 'right';
    this.isAttacking = false;
    this.onGround = false;
    this.special = 0;
    this.specialMax = PLAYER_DEFAULTS.specialMax;
    this.specialGain = profile.specialGain || 1.0;
    this.comboCounter = 0;
    this.comboTimer = 0;
    this.comboResetTime = 1000;
    this.invulnerable = false;
    this.money = 0;

    this.attackHitboxes = scene.add.group();
    this.keys = scene.keys;
    this.body.setGravityY(this.gravity);
    this.sprite.setTexture(profile.id + '_idle');

    this.scene.input.keyboard.on('keydown_TAB', ()=> this.cycleCharacter());
    this.lastDamageTime = 0;
    this.damageCooldown = 500;
  }

  cycleCharacter(){
    const next = (this.scene.playerSelectIndex + 1) % this.scene.characters.length;
    this.scene.playerSelectIndex = next;
    this.profile = this.scene.characters[next];
    this.speed = this.profile.speed;
    this.charSwapVisual();
    this.scene.charText.setText('CHAR: ' + this.profile.name + ' (Special: ' + this.profile.specialKey.toUpperCase() + ')');
  }

  charSwapVisual() {
    const fx = this.scene.add.rectangle(this.x, this.y - 60, 120, 40, 0xffffff, 0.08).setDepth(60);
    this.scene.tweens.add({ targets: fx, alpha:0, duration:420, onComplete: ()=>fx.destroy() });
  }

  update(time, delta) {
    const keys = this.keys;
    this.onGround = this.body.onFloor();
    let vx = 0;
    if (keys.left.isDown) vx -= this.speed;
    if (keys.right.isDown) vx += this.speed;
    this.body.setVelocityX(vx);
    if (vx < 0) { this.facing = 'left'; this.sprite.flipX = true; }
    else if (vx > 0) { this.facing = 'right'; this.sprite.flipX = false; }

    if (Phaser.Input.Keyboard.JustDown(keys.up) && this.onGround) {
      this.body.setVelocityY(-this.jumpSpeed);
      this.playAnim('jump');
    }

    if (!this.isAttacking) {
      if (!this.onGround) this.playAnim('jump');
      else if (vx !== 0) this.playAnim('walk');
      else this.playAnim('idle');
    }

    if (Phaser.Input.Keyboard.JustDown(keys.light) && time > this.attackTimer) this.lightAttack(time);
    if (Phaser.Input.Keyboard.JustDown(keys.heavy) && time > this.heavyTimer) this.heavyAttack(time);

    // SPECIAL: check the key assigned to this.profile.specialKey (e.g., 'q','e','r')
    const specialKeyName = (this.profile && this.profile.specialKey) ? this.profile.specialKey : null;
    if (specialKeyName && this.scene.keys[specialKeyName]) {
      if (Phaser.Input.Keyboard.JustDown(this.scene.keys[specialKeyName])) {
        if (this.special >= PLAYER_DEFAULTS.specialCost) this.useSpecial();
        else {
          this.scene.tweens.add({ targets: this, scaleX: 1.02, scaleY:1.02, yoyo: true, duration:120 });
        }
      }
    }

    if (this.comboCounter > 0 && time > this.comboTimer) this.comboCounter = 0;

    if (this.y > GAME_HEIGHT + 500) {
      this.x = this.scene.physics.world.bounds.width/2;
      this.y = GAME_HEIGHT - 200;
      this.body.setVelocity(0,0);
      this.hp = Math.max(10, this.hp - 12);
    }
  }

  playAnim(anim){
    const tex = this.profile.id + '_' + anim;
    if (this.sprite.texture.key !== tex) {
      if (this.scene.textures.exists(tex)) this.sprite.setTexture(tex);
      else this.sprite.setTexture(this.profile.id + '_idle');
    }
  }

  lightAttack(time) {
    this.isAttacking = true;
    this.attackTimer = time + this.attackCooldown;
    this.playAnim('punch');
    const hb = this.scene.hitboxPool.get();
    hb.setActive(true); hb.setVisible(false);
    hb.body.enable = true;
    const dir = (this.facing === 'right') ? 1 : -1;
    const ox = dir * 40;
    hb.x = this.x + ox; hb.y = this.y - 36;
    hb.width = 50; hb.height = 22;
    hb.body.setSize(hb.width, hb.height);
    this.scene.physics.add.overlap(hb, this.scene.enemies, (hitRect, enemy) => {
      if (!enemy._hitThisFrame) {
        enemy._hitThisFrame = true;
        this.scene.time.delayedCall(40, ()=> enemy._hitThisFrame = false);
        const dmg = this.profile.power || 10;
        enemy.takeDamage(dmg, this);
        this.onHitEnemy(enemy, dmg);
      }
    }, null, this);
    this.scene.time.delayedCall(90, ()=>{
      try { hb.body.enable = false; hb.setActive(false); this.scene.hitboxPool.release(hb); } catch(e){}
    });
    this.scene.time.delayedCall(160, ()=> this.isAttacking = false);
  }

  heavyAttack(time) {
    this.isAttacking = true;
    this.heavyTimer = time + this.heavyCooldown;
    this.playAnim('heavy');
    const hb = this.scene.hitboxPool.get();
    hb.setActive(true); hb.setVisible(false);
    hb.body.enable = true;
    const dir = (this.facing === 'right') ? 1 : -1;
    const ox = dir * 48;
    hb.x = this.x + ox; hb.y = this.y - 36;
    hb.width = 80; hb.height = 30;
    hb.body.setSize(hb.width, hb.height);
    this.scene.physics.add.overlap(hb, this.scene.enemies, (hitRect, enemy) => {
      if (!enemy._hitThisFrame) {
        enemy._hitThisFrame = true;
        this.scene.time.delayedCall(60, ()=> enemy._hitThisFrame = false);
        const dmg = (this.profile.power || 10) * 1.8;
        enemy.takeDamage(dmg, this);
        enemy.body.velocity.x = dir * 260;
        this.onHitEnemy(enemy, dmg, { heavy:true });
      }
    }, null, this);
    this.scene.time.delayedCall(160, ()=>{ hb.body.enable = false; hb.setActive(false); this.scene.hitboxPool.release(hb); });
    this.scene.time.delayedCall(300, ()=> this.isAttacking = false);
  }

  useSpecial(){
    this.special -= PLAYER_DEFAULTS.specialCost;
    this.playAnim('special');
    const radius = 160;
    const fx = this.scene.add.circle(this.x, this.y - 40, 8, 0xffff88).setDepth(50);
    this.scene.tweens.add({
      targets: fx, radius: radius, alpha:0, scale:1.0, duration: 420, ease:'Quad.easeOut',
      onUpdate: (tws)=>{
        this.scene.enemies.getChildren().forEach(e=>{
          if (!e.active) return;
          const dist = Phaser.Math.Distance.Between(this.x, this.y, e.x, e.y);
          if (dist < fx.radius + 8 && !e._hitThisFrame) {
            e._hitThisFrame = true;
            this.scene.time.delayedCall(60, ()=> e._hitThisFrame = false);
            e.takeDamage(22, this);
            e.body.velocity.y = -120;
          }
        });
      },
      onComplete: ()=> fx.destroy()
    });
    this.invulnerable = true;
    this.scene.time.delayedCall(500, ()=> this.invulnerable = false);
  }

  onHitEnemy(enemy, dmg, opts = {}){
    const gain = (6 + Math.round(dmg/3)) * this.specialGain;
    this.special = Phaser.Math.Clamp(this.special + gain, 0, this.specialMax);
    this.comboCounter++;
    this.comboTimer = this.scene.time.now + this.comboResetTime;
    if (Math.random() < 0.25) this.money += 1;
    if (this.scene.cameras.main) this.scene.cameras.main.shake(40, 0.003);
  }

  takeDamage(amount, source){
    if (this.invulnerable) return;
    const now = this.scene.time.now;
    if (now < this.lastDamageTime + this.damageCooldown) return;
    this.lastDamageTime = now;
    const def = this.profile.defense || 0;
    const actual = Math.max(1, Math.round(amount - def*0.6));
    this.hp = Math.max(0, this.hp - actual);
    this.scene.tweens.add({ targets: this, x: this.x + Phaser.Math.Between(-6,6), duration:60, yoyo:true });
    this.invulnerable = true;
    this.scene.time.delayedCall(700, ()=> this.invulnerable = false);
    this.sprite.setTint(0xff4444);
    this.scene.time.delayedCall(180, ()=> this.sprite.clearTint());
    if (this.hp <= 0) this.die();
  }

  die(){
    this.scene.cameras.main.flash(220, 120,0,0);
    this.hp = Math.floor(this.maxHP * 0.5);
    this.x = this.scene.physics.world.bounds.width/2;
    this.y = GAME_HEIGHT - 180;
    this.body.setVelocity(0,0);
  }

  comboResetAfter(ms) { this.scene.time.delayedCall(ms, ()=> this.comboCounter = 0); }
}

/* Boot game */
const config = {
  type: Phaser.AUTO,
  width: GAME_WIDTH,
  height: GAME_HEIGHT,
  parent: 'game',
  backgroundColor: '#111',
  physics: { default: 'arcade', arcade: { gravity: { y: 0 }, debug: false } },
  scene: [Boot, Preload, Main]
};

const game = new Phaser.Game(config);

</script>
</body>
</html>
